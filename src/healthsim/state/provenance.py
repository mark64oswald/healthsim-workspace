"""Provenance tracking for entity lineage.

Tracks how entities were created across all HealthSim products:
- PatientSim: patients, encounters, diagnoses, labs, vitals, medications
- MemberSim: members, claims, authorizations, accumulators
- RxMemberSim: rx_members, prescriptions, pharmacy_claims, prior_auths
"""

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, Any

from pydantic import BaseModel, Field

if TYPE_CHECKING:
    from healthsim.state.entity import EntityWithProvenance


class SourceType(str, Enum):
    """How an entity was created."""

    LOADED = "loaded"  # Loaded from saved workspace
    GENERATED = "generated"  # Generated by a skill or generator
    DERIVED = "derived"  # Derived from other entities


class Provenance(BaseModel):
    """Tracks how an entity was created.

    Provides lineage information for all entities across HealthSim products,
    enabling reproducibility and audit trails.
    """

    source_type: SourceType
    source_system: str | None = None
    skill_used: str | None = None
    derived_from: list[str] = Field(default_factory=list)
    created_at: datetime = Field(default_factory=datetime.now)
    generation_params: dict[str, Any] = Field(default_factory=dict)

    @classmethod
    def generated(cls, skill_used: str | None = None, **params: Any) -> Provenance:
        """Create provenance for a generated entity.

        Args:
            skill_used: Name of the skill used for generation
            **params: Generation parameters to record

        Returns:
            Provenance instance with GENERATED source type
        """
        return cls(
            source_type=SourceType.GENERATED,
            skill_used=skill_used,
            generation_params=params,
        )

    @classmethod
    def loaded(cls, source_system: str) -> Provenance:
        """Create provenance for a loaded entity.

        Args:
            source_system: System the entity was loaded from

        Returns:
            Provenance instance with LOADED source type
        """
        return cls(source_type=SourceType.LOADED, source_system=source_system)

    @classmethod
    def derived(cls, derived_from: list[str]) -> Provenance:
        """Create provenance for a derived entity.

        Args:
            derived_from: List of entity IDs this entity was derived from

        Returns:
            Provenance instance with DERIVED source type
        """
        return cls(source_type=SourceType.DERIVED, derived_from=derived_from)


class ProvenanceSummary(BaseModel):
    """Aggregate provenance statistics for a workspace.

    Provides high-level summary of entity origins without
    exposing individual entity details.
    """

    total_entities: int = 0
    by_source_type: dict[str, int] = Field(default_factory=dict)
    source_systems: list[str] = Field(default_factory=list)
    skills_used: list[str] = Field(default_factory=list)

    @classmethod
    def from_entities(cls, entities: dict[str, list[EntityWithProvenance]]) -> ProvenanceSummary:
        """Build summary from entity collections.

        Args:
            entities: Dict mapping entity type to list of entities with provenance

        Returns:
            Aggregate provenance summary
        """
        # Import here to avoid circular dependency
        from .entity import EntityWithProvenance

        total = 0
        by_type: dict[str, int] = {}
        systems: set[str] = set()
        skills: set[str] = set()

        for entity_list in entities.values():
            for entity in entity_list:
                if not isinstance(entity, EntityWithProvenance):
                    continue
                total += 1
                source = entity.provenance.source_type.value
                by_type[source] = by_type.get(source, 0) + 1
                if entity.provenance.source_system:
                    systems.add(entity.provenance.source_system)
                if entity.provenance.skill_used:
                    skills.add(entity.provenance.skill_used)

        return cls(
            total_entities=total,
            by_source_type=by_type,
            source_systems=sorted(systems),
            skills_used=sorted(skills),
        )
